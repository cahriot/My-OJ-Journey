## Journey：
2020/6/9 AC.002  
### Des
考虑将数字转换为字符串的不同种可能。a-z->0-25一一对应。

### One
想法1：(感觉像个组合问题)，字符串长为一种，然后寻找1，2，的个数，加上1的个数，2的判断后面数字是否小于6，是加上，否不加。

翻了下题解，这种想法可以转为递归双百（写法比我最开始的思路优雅得多）
```golang
func translateNum(num int) int {
    if num<=9{
        return 1
    }//一个数字仅有一种
    tmp:=num%100
    if tmp<=9||tmp>=26{
        return translateNum(num/10)
    }
    return translateNum(num/10)+translateNum(num/100)
}
```
- 不要忘了程序中分数不是四舍五入是直接去掉
- 递归总是反直觉而很难理解的...这个递归的思路是递归地判断末两位，也就是我们想的1，2后面的数，但这里直接改成10-25就好了，在这之间地再次分割也就是分为/10和/100(注意到translateNum(0)=1)，而如果不在里面说明末两位只有一种可能性，就可以直接去掉末位(/10)重新考虑。
- 或者直接想/10->代表单独看最后一位为一种，/100->代表单独看最后两位为一种。两种相加即为答案了

时间复杂度O(len(strcov.Itoa(num)))递归次数,空间复杂度O(len(strcov.Itoa(num))*C)递归次数乘以tmp大小

也可以硬搜,深优和广优

### Two
官方题解，动态硅划