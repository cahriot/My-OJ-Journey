## CH1. 算法准备
### 1.5 以高效算法为目标
- 复杂度：主循环次数
- 运行时间：限制1s，则10^6OK，10^7勉强，10^8很悬，即O(n^2)时，n=1000就还OK

### 1.6 热身
- POJ No.1852 蚂蚁相遇返回问题：求最长和最短杠上停留时间
2^20时达到10^6,2^30达到10^9;故暴力求解限制很大

想像两蚂蚁相遇后直接穿过对方，则与事实情况仅仅是个体变换而已，则每只蚂蚁可看成独立的，求离端点最长和最远的距离即可(循环遍历一次求极值)

- 抽签问题：n个有数字纸片，抽4次，判断是否能和为m
暴力求解四重循环，n若为1000，爆表...
1. 二分查找：O(n^3logn)
二分查找O(logn)复杂度，n变成10^9，log_2(n)也仅仅是30而已。

排序O(nlogn)，循环O(n^3logn),按O(n^3logn)算

排序:sort(k,k+n)

二分：搜索m-k[a]-k[b]-k[c]
``` cpp
bool binary_search(int x){
    int l=0;r=n;
    while(r-l>=1){
        int i = (l+r)/2;
        if(k[i]==x) return true;
        else if (k[i] < x) l=i+1;
        else r=i;
    }
    return false;
}
```
2. O(n^2logn)
n=1000仅使用一层二分O(n^3logn)也是不够的

kc+kd=m-ka-kb；预先枚举kc+kd所得n^2个数字并排好序，则可二分

1. 排序O(n^2logn)
2. 循环O(n^2logn)
3. 总共O(n^2logn),n=1000也没问题
solve(){
    //枚举k[c]+k[d]得n*n大小数组kk
    //对kk排序
    //对内侧两循环二分查找m-k[a]-k[b]
}